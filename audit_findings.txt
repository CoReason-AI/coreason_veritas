
Audit Findings for coreason_veritas
===================================

1. Recursion Issue (FIXED)
   - Issue: Nested calls to governed functions were previously causing test failures (or were flagged as potential issues).
   - Status: Verified that recursive calls function correctly with the current implementation. The `xfail` marker was removed.

2. Audit Sink Fail-Open (FIXED)
   - Issue: The `IERLogger` was catching exceptions from audit sinks and logging them, but allowing execution to proceed. This violated the "Fail Closed" requirement for GxP compliance.
   - Fix: Modified `src/coreason_veritas/auditor.py` to re-raise exceptions from sinks, causing the application to crash/halt if auditing fails.

3. Cryptographic Replay Vulnerability (OPEN)
   - Issue: The `SignatureValidator` in `gatekeeper.py` verifies the signature of the payload, but does not check for timestamps, nonces, or unique transaction IDs within the payload itself.
   - Impact: An attacker could capture a valid signed payload (e.g., a "Run Clinical Analysis" command) and replay it later, potentially triggering unauthorized duplicate executions.
   - Recommendation: The asset/spec payload schema should enforce the presence of a `timestamp` or `nonce` field, and the validator should check that this timestamp is within an acceptable window (e.g., 5 minutes).

4. JSON Canonicalization Issues (Potential)
   - Issue: `json.dumps(..., sort_keys=True)` is used for canonicalization. While common, this is not a strictly standardized canonical JSON format (e.g., handling of floating point numbers, unicode, spacing).
   - Impact: Different environments or JSON libraries might serialize the same dictionary slightly differently, causing signature verification failures.
   - Recommendation: Use a dedicated canonical JSON library or strict serialization rules (e.g., JCS - RFC 8785) if cross-language compatibility is needed.

5. Key Management
   - Issue: Public keys are loaded from environment variables (`COREASON_VERITAS_PUBLIC_KEY`).
   - Status: Acceptable for a library, assuming the environment is secure.

6. OpenTelemetry Overhead
   - Observation: The current implementation creates a new Span and potentially flushes it (batch processor) for every function call. In high-throughput scenarios, this might add latency.
   - Status: Acceptable for "Governance Layer" where auditability > performance.
